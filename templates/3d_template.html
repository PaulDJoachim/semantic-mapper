<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            margin: 0;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #ffffff;
            overflow: hidden;
        }}

        #container {{
            display: flex;
            height: 100vh;
        }}

        #canvas-container {{
            flex: 1;
            position: relative;
        }}

        #info-panel {{
            width: 350px;
            background: #1a1a1a;
            border-left: 1px solid #333;
            padding: 20px;
            overflow-y: auto;
        }}

        .panel-section {{
            background: #222;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
        }}

        .panel-section h3 {{
            margin: 0 0 10px 0;
            color: #fff;
            font-size: 16px;
        }}

        .stat-row {{
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 14px;
        }}

        .controls {{
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 100;
        }}

        .controls button {{
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 10px 15px;
            margin-right: 10px;
            border-radius: 4px;
            cursor: pointer;
            transition: background 0.2s;
        }}

        .controls button:hover {{
            background: #444;
        }}

        #selected-info {{
            max-height: 300px;
            overflow-y: auto;
        }}

        .sample-text {{
            background: #333;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            line-height: 1.4;
            margin-top: 8px;
        }}

        .cluster-legend {{
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }}

        .cluster-item {{
            display: flex;
            align-items: center;
            font-size: 12px;
        }}

        .cluster-color {{
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 6px;
        }}

        .help-text {{
            font-size: 11px;
            color: #aaa;
            line-height: 1.3;
        }}
    </style>
</head>
<body>
    <div id="container">
        <div id="canvas-container">
            <div class="controls">
                <button id="toggle-rotation">‚è∏Ô∏è Pause</button>
                <button id="reset-view">üè† Reset</button>
                <button id="toggle-labels">üè∑Ô∏è Labels</button>
            </div>
        </div>

        <div id="info-panel">
            <div class="panel-section">
                <h3>Cluster Overview</h3>
                <div id="cluster-stats"></div>
                <div class="cluster-legend" id="cluster-legend"></div>
            </div>

            <div class="panel-section">
                <h3>Selected Sample</h3>
                <div id="selected-info">
                    <p class="help-text">Click on a ray endpoint to view details</p>
                </div>
            </div>

            <div class="panel-section">
                <h3>Instructions</h3>
                <div class="help-text">
                    ‚Ä¢ Each ray represents a text continuation<br>
                    ‚Ä¢ Ray direction = semantic meaning in 3D space<br>
                    ‚Ä¢ Ray length = model confidence<br>
                    ‚Ä¢ Colors indicate detected clusters<br>
                    ‚Ä¢ Similar directions = similar meanings<br>
                    ‚Ä¢ Mouse: rotate view, click rays to inspect
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const clusterData = {cluster_data};

        class ClusterVisualization {{
            constructor() {{
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.rayGroup = null;
                this.sphereGroup = null;
                this.selectedSphere = null;
                this.isRotating = true;
                this.showLabels = false;

                this.init();
                this.createVisualization();
                this.setupEventListeners();
                this.animate();
            }}

            init() {{
                const container = document.getElementById('canvas-container');
                const rect = container.getBoundingClientRect();

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x0a0a0a);

                this.camera = new THREE.PerspectiveCamera(
                    75, rect.width / rect.height, 0.1, 1000
                );
                this.camera.position.set(3, 2, 3);

                this.renderer = new THREE.WebGLRenderer({{ antialias: true }});
                this.renderer.setSize(rect.width, rect.height);
                this.renderer.shadowMap.enabled = true;
                container.appendChild(this.renderer.domElement);

                // Lighting
                const ambient = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambient);

                const directional = new THREE.DirectionalLight(0xffffff, 0.8);
                directional.position.set(5, 5, 5);
                this.scene.add(directional);

                // Add coordinate system
                const axes = new THREE.AxesHelper(1.5);
                this.scene.add(axes);

                // Origin sphere
                const originGeo = new THREE.SphereGeometry(0.03, 16, 16);
                const originMat = new THREE.MeshBasicMaterial({{ color: 0xffffff }});
                const origin = new THREE.Mesh(originGeo, originMat);
                this.scene.add(origin);
            }}

            createVisualization() {{
                this.rayGroup = new THREE.Group();
                this.sphereGroup = new THREE.Group();

                clusterData.samples.forEach((sample, index) => {{
                    const direction = new THREE.Vector3(...sample.direction);
                    const rayLength = 1.0 + sample.confidence * 0.8;
                    const endPoint = direction.multiplyScalar(rayLength);

                    // Create ray
                    const rayGeo = new THREE.BufferGeometry();
                    rayGeo.setFromPoints([
                        new THREE.Vector3(0, 0, 0),
                        endPoint
                    ]);

                    const rayMat = new THREE.LineBasicMaterial({{
                        color: sample.color,
                        opacity: 0.7,
                        transparent: true
                    }});

                    const ray = new THREE.Line(rayGeo, rayMat);
                    this.rayGroup.add(ray);

                    // Create endpoint sphere
                    const sphereGeo = new THREE.SphereGeometry(
                        0.025 + sample.confidence * 0.02, 12, 12
                    );
                    const sphereMat = new THREE.MeshPhongMaterial({{
                        color: sample.color,
                        transparent: true,
                        opacity: 0.9
                    }});

                    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                    sphere.position.copy(endPoint);
                    sphere.userData = {{ sample, index }};
                    this.sphereGroup.add(sphere);
                }});

                this.scene.add(this.rayGroup);
                this.scene.add(this.sphereGroup);

                this.updateUI();
            }}

            updateUI() {{
                // Update cluster stats
                const statsDiv = document.getElementById('cluster-stats');
                let statsHTML = '';
                for (const [cluster, count] of Object.entries(clusterData.stats)) {{
                    const displayName = cluster === 'noise' ? 'Noise' : cluster.replace('_', ' ').toUpperCase();
                    statsHTML += `<div class="stat-row"><span>${{displayName}}:</span><span>${{count}}</span></div>`;
                }}
                statsDiv.innerHTML = statsHTML;

                // Update legend
                const legendDiv = document.getElementById('cluster-legend');
                const clusterColors = {{
                    'noise': '#ffeaa7',
                    'cluster_0': '#ff6b6b',
                    'cluster_1': '#4ecdc4',
                    'cluster_2': '#45b7d1',
                    'cluster_3': '#96ceb4',
                    'cluster_4': '#fd79a8',
                    'cluster_5': '#fdcb6e'
                }};

                let legendHTML = '';
                for (const cluster of Object.keys(clusterData.stats)) {{
                    const color = clusterColors[cluster] || '#cccccc';
                    const name = cluster === 'noise' ? 'Noise' : cluster.replace('_', ' ').toUpperCase();
                    legendHTML += `
                        <div class="cluster-item">
                            <div class="cluster-color" style="background-color: ${{color}}"></div>
                            ${{name}}
                        </div>
                    `;
                }}
                legendDiv.innerHTML = legendHTML;
            }}

            setupEventListeners() {{
                // Mouse controls
                let isDragging = false;
                let previousMousePosition = {{ x: 0, y: 0 }};

                this.renderer.domElement.addEventListener('mousedown', (e) => {{
                    isDragging = false;
                }});

                this.renderer.domElement.addEventListener('mousemove', (e) => {{
                    if (e.buttons === 1) {{
                        isDragging = true;
                        const deltaMove = {{
                            x: e.offsetX - previousMousePosition.x,
                            y: e.offsetY - previousMousePosition.y
                        }};

                        const deltaRotationQuaternion = new THREE.Quaternion()
                            .setFromEuler(new THREE.Euler(
                                deltaMove.y * 0.01,
                                deltaMove.x * 0.01,
                                0,
                                'XYZ'
                            ));

                        this.camera.quaternion.multiplyQuaternions(deltaRotationQuaternion, this.camera.quaternion);
                    }}

                    previousMousePosition = {{ x: e.offsetX, y: e.offsetY }};
                }});

                this.renderer.domElement.addEventListener('click', (e) => {{
                    if (!isDragging) {{
                        this.handleClick(e);
                    }}
                }});

                // Control buttons
                document.getElementById('toggle-rotation').addEventListener('click', () => {{
                    this.isRotating = !this.isRotating;
                    document.getElementById('toggle-rotation').textContent =
                        this.isRotating ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                }});

                document.getElementById('reset-view').addEventListener('click', () => {{
                    this.camera.position.set(3, 2, 3);
                    this.camera.lookAt(0, 0, 0);
                }});

                document.getElementById('toggle-labels').addEventListener('click', () => {{
                    this.showLabels = !this.showLabels;
                    // Label toggle functionality can be added here
                }});

                // Handle window resize
                window.addEventListener('resize', () => {{
                    const container = document.getElementById('canvas-container');
                    const rect = container.getBoundingClientRect();
                    this.camera.aspect = rect.width / rect.height;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(rect.width, rect.height);
                }});
            }}

            handleClick(event) {{
                const rect = this.renderer.domElement.getBoundingClientRect();
                const mouse = new THREE.Vector2();
                mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(mouse, this.camera);

                const intersects = raycaster.intersectObjects(this.sphereGroup.children);

                if (intersects.length > 0) {{
                    const sphere = intersects[0].object;
                    this.selectSample(sphere);
                }}
            }}

            selectSample(sphere) {{
                // Reset previous selection
                if (this.selectedSphere) {{
                    this.selectedSphere.material.emissive.setHex(0x000000);
                }}

                // Highlight new selection
                this.selectedSphere = sphere;
                sphere.material.emissive.setHex(0x444444);

                // Update info panel
                const sample = sphere.userData.sample;
                const infoDiv = document.getElementById('selected-info');

                const clusterName = sample.cluster === -1 ? 'Noise' : `Cluster ${{sample.cluster}}`;

                infoDiv.innerHTML = `
                    <div class="stat-row"><strong>Cluster:</strong> ${{clusterName}}</div>
                    <div class="stat-row"><strong>Confidence:</strong> ${{sample.confidence.toFixed(3)}}</div>
                    <div class="stat-row"><strong>Direction:</strong> (${{sample.direction.map(x => x.toFixed(2)).join(', ')}})</div>
                    <div class="sample-text">${{sample.text}}</div>
                `;
            }}

            animate() {{
                requestAnimationFrame(() => this.animate());

                if (this.isRotating) {{
                    this.rayGroup.rotation.y += 0.003;
                    this.sphereGroup.rotation.y += 0.003;
                }}

                this.renderer.render(this.scene, this.camera);
            }}
        }}

        // Initialize when page loads
        window.addEventListener('load', () => {{
            new ClusterVisualization();
        }});
    </script>
</body>
</html>