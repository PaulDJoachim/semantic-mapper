<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{title}</title>
    <style>
        body {{
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #1a1a1a;
            color: #ffffff;
            display: flex;
            gap: 20px;
            height: calc(100vh - 40px);
        }}

        #tree-container {{
            flex: 1;
            min-width: 600px;
            display: flex;
            flex-direction: column;
        }}

        #canvas {{
            border: 1px solid #444;
            background: #000;
            cursor: grab;
            flex: 1;
            width: 100%;
        }}

        #canvas:active {{
            cursor: grabbing;
        }}

        #cluster-panel {{
            width: 400px;
            background: #222;
            border-radius: 8px;
            padding: 20px;
            max-height: calc(100vh - 40px);
            overflow-y: auto;
        }}

        #cluster-panel h3 {{
            margin-top: 0;
            color: #fff;
        }}

        #cluster-viewer {{
            width: 100%;
            height: 300px;
            background: #111;
            border: 1px solid #333;
            border-radius: 4px;
            margin-bottom: 15px;
        }}

        .cluster-info {{
            background: #333;
            border-radius: 4px;
            padding: 10px;
            margin-bottom: 10px;
            font-size: 14px;
        }}

        .sample-text {{
            background: #444;
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            margin: 5px 0;
            border-left: 3px solid;
        }}

        .cluster-group {{
            margin-bottom: 15px;
            border: 1px solid #555;
            border-radius: 6px;
            overflow: hidden;
        }}

        .cluster-header {{
            background: #333;
            padding: 12px;
            cursor: pointer;
            user-select: none;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: bold;
        }}

        .cluster-header:hover {{
            background: #3a3a3a;
        }}

        .cluster-content {{
            padding: 8px;
            background: #2a2a2a;
        }}

        .cluster-content.collapsed {{
            display: none;
        }}

        .expand-icon {{
            transition: transform 0.2s;
        }}

        .expand-icon.collapsed {{
            transform: rotate(-90deg);
        }}

        .controls {{
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 20px;
            flex-wrap: wrap;
            flex-shrink: 0;
        }}

        .control-group {{
            display: flex;
            align-items: center;
            gap: 8px;
        }}

        .controls input[type="range"] {{
            width: 120px;
        }}

        button {{
            padding: 8px 16px;
            background: #333;
            color: #fff;
            border: 1px solid #555;
            border-radius: 4px;
            cursor: pointer;
        }}

        button:hover {{
            background: #444;
        }}

        .hidden {{
            display: none;
        }}
    </style>
</head>
<body>
    <div id="tree-container">
        <div class="controls">
            <div class="control-group">
                <label>Zoom:</label>
                <input type="range" id="zoomSlider" min="0.1" max="3" step="0.1" value="1">
                <span id="zoomValue">1.0</span>
            </div>
            <div class="control-group">
                <label>Node Size:</label>
                <input type="range" id="nodeSizeSlider" min="0.5" max="2" step="0.1" value="1">
                <span id="nodeSizeValue">1.0</span>
            </div>
            <div class="control-group">
                <label>Layout:</label>
                <select id="layoutSelect">
                    <option value="radial">Radial</option>
                    <option value="tree">Tree</option>
                </select>
            </div>
            <button id="resetView">Reset View</button>
        </div>

        <canvas id="canvas"></canvas>
    </div>

    <div id="cluster-panel">
        <div id="no-selection">
            <h3>Cluster Visualization</h3>
            <p>Click on a node to see its semantic clusters</p>
        </div>

        <div id="cluster-content" class="hidden">
            <h3 id="selected-node-text">Selected Node</h3>
            <canvas id="cluster-viewer"></canvas>
            <div id="cluster-stats"></div>
            <div id="cluster-samples"></div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const treeData = {tree_data};

        class ClusterVisualizer {{
            constructor(canvas, options = {{}}) {{
                this.canvas = canvas;
                this.options = {{
                    autoRotate: options.autoRotate !== false,
                    fullscreen: options.fullscreen === true,
                    ...options
                }};

                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.rayGroup = null;
                this.sphereGroup = null;
                this.isRotating = this.options.autoRotate;
                this.currentData = null;

                this.init();
            }}

            init() {{
                if (!window.THREE) {{
                    console.warn('Three.js not available');
                    return;
                }}

                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x111111);

                const rect = this.canvas.getBoundingClientRect();
                this.camera = new THREE.PerspectiveCamera(75, rect.width / rect.height, 0.1, 1000);

                // Start with a better initial camera position
                this.resetCamera();

                this.renderer = new THREE.WebGLRenderer({{ canvas: this.canvas, antialias: true }});
                this.renderer.setSize(rect.width, rect.height);

                const ambient = new THREE.AmbientLight(0x404040, 0.6);
                this.scene.add(ambient);

                const directional = new THREE.DirectionalLight(0xffffff, 0.8);
                directional.position.set(1, 1, 1);
                this.scene.add(directional);

                const axes = new THREE.AxesHelper(0.8);
                this.scene.add(axes);

                const originGeo = new THREE.SphereGeometry(0.02, 16, 16);
                const originMat = new THREE.MeshBasicMaterial({{ color: 0xffffff }});
                const origin = new THREE.Mesh(originGeo, originMat);
                this.scene.add(origin);

                this.rayGroup = new THREE.Group();
                this.sphereGroup = new THREE.Group();
                this.scene.add(this.rayGroup);
                this.scene.add(this.sphereGroup);

                this.setupControls();
                this.animate();
            }}

            resetCamera() {{
                // Position camera to look at origin from a good angle
                this.camera.position.set(1.5, 1.0, 1.5);
                this.camera.lookAt(0, 0, 0);
            }}

            setupControls() {{
                if (!this.renderer) return;

                let isDragging = false;
                let previousMouse = {{ x: 0, y: 0 }};

                this.canvas.addEventListener('mousedown', (e) => {{
                    isDragging = false;
                    previousMouse = {{ x: e.offsetX, y: e.offsetY }};
                }});

                this.canvas.addEventListener('mousemove', (e) => {{
                    if (e.buttons === 1) {{
                        isDragging = true;
                        const deltaMove = {{
                            x: e.offsetX - previousMouse.x,
                            y: e.offsetY - previousMouse.y
                        }};

                        // Orbit around the origin
                        const spherical = new THREE.Spherical();
                        spherical.setFromVector3(this.camera.position);

                        spherical.theta -= deltaMove.x * 0.01;
                        spherical.phi += deltaMove.y * 0.01;

                        // Clamp phi to avoid flipping
                        spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));

                        this.camera.position.setFromSpherical(spherical);
                        this.camera.lookAt(0, 0, 0);
                    }}
                    previousMouse = {{ x: e.offsetX, y: e.offsetY }};
                }});

                this.canvas.addEventListener('wheel', (e) => {{
                    e.preventDefault();
                    const distance = this.camera.position.length();
                    const newDistance = Math.max(0.5, Math.min(5, distance + e.deltaY * 0.01));
                    this.camera.position.normalize().multiplyScalar(newDistance);
                }});
            }}

            showClusters(clusterData) {{
                this.currentData = clusterData;
                this.clear();

                if (!clusterData || !clusterData.samples) return;

                clusterData.samples.forEach(sample => {{
                    const direction = new THREE.Vector3(...sample.direction);
                    const rayLength = 0.6 + sample.confidence * 0.4;
                    const endPoint = direction.multiplyScalar(rayLength);

                    const rayGeo = new THREE.BufferGeometry();
                    rayGeo.setFromPoints([new THREE.Vector3(0, 0, 0), endPoint]);

                    const rayMat = new THREE.LineBasicMaterial({{
                        color: sample.color,
                        opacity: 0.8,
                        transparent: true
                    }});

                    const ray = new THREE.Line(rayGeo, rayMat);
                    this.rayGroup.add(ray);

                    const sphereGeo = new THREE.SphereGeometry(0.015, 8, 8);
                    const sphereMat = new THREE.MeshPhongMaterial({{ color: sample.color }});
                    const sphere = new THREE.Mesh(sphereGeo, sphereMat);
                    sphere.position.copy(endPoint);
                    this.sphereGroup.add(sphere);
                }});

                // Reset camera to center the new clusters
                this.resetCamera();
            }}

            clear() {{
                this.rayGroup.clear();
                this.sphereGroup.clear();
            }}

            animate() {{
                if (!this.renderer) return;

                requestAnimationFrame(() => this.animate());

                if (this.isRotating && this.rayGroup.children.length > 0) {{
                    this.rayGroup.rotation.y += 0.005;
                    this.sphereGroup.rotation.y += 0.005;
                }}

                this.renderer.render(this.scene, this.camera);
            }}
        }}

        class TreeVisualizer {{
            constructor(canvas, treeData) {{
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.treeData = treeData;
                this.selectedNode = null;
                this.clusterViewer = null;

                this.viewState = {{
                    offsetX: 0,
                    offsetY: 0,
                    zoom: 1,
                    nodeScale: 1,
                    layout: 'radial'
                }};

                this.nodes = [];
                this.edges = [];
                this.expandedNodes = new Set(); // Track expanded nodes
                this.nodeDimensionsCache = new Map();

                this.setupCanvas();
                this.setupEventListeners();
                this.processTree();
                this.render();
            }}

            setupCanvas() {{
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }}

            resizeCanvas() {{
                const container = document.getElementById('tree-container');
                const controls = document.querySelector('.controls');
                const availableWidth = container.clientWidth;
                const availableHeight = container.clientHeight - controls.offsetHeight - 40; // padding

                this.canvas.width = availableWidth;
                this.canvas.height = availableHeight;

                // Center the view on resize
                this.viewState.offsetX = availableWidth / 2;
                this.viewState.offsetY = availableHeight / 2;

                this.nodeDimensionsCache.clear();
                this.render();
            }}

            initClusterViewer() {{
                if (!this.clusterViewer) {{
                    const canvas3d = document.getElementById('cluster-viewer');
                    this.clusterViewer = new ClusterVisualizer(canvas3d, {{
                        fullscreen: false,
                        autoRotate: true
                    }});
                }}
                return this.clusterViewer;
            }}

            setupEventListeners() {{
                let isDragging = false;
                let lastX, lastY;
                let dragStarted = false;

                this.canvas.addEventListener('mousedown', (e) => {{
                    isDragging = true;
                    dragStarted = false;
                    lastX = e.clientX;
                    lastY = e.clientY;
                }});

                this.canvas.addEventListener('mousemove', (e) => {{
                    if (isDragging) {{
                        const deltaX = e.clientX - lastX;
                        const deltaY = e.clientY - lastY;

                        if (Math.abs(deltaX) > 3 || Math.abs(deltaY) > 3) {{
                            dragStarted = true;
                        }}

                        this.viewState.offsetX += deltaX;
                        this.viewState.offsetY += deltaY;
                        lastX = e.clientX;
                        lastY = e.clientY;
                        this.render();
                    }}
                }});

                this.canvas.addEventListener('mouseup', (e) => {{
                    if (isDragging && !dragStarted) {{
                        this.handleClick(e);
                    }}
                    isDragging = false;
                    dragStarted = false;
                }});

                // Mouse wheel zoom
                this.canvas.addEventListener('wheel', (e) => {{
                    e.preventDefault();
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    const newZoom = Math.max(0.1, Math.min(3, this.viewState.zoom * zoomFactor));

                    if (newZoom !== this.viewState.zoom) {{
                        this.viewState.zoom = newZoom;
                        document.getElementById('zoomSlider').value = newZoom;
                        document.getElementById('zoomValue').textContent = newZoom.toFixed(1);
                        this.nodeDimensionsCache.clear();
                        this.render();
                    }}
                }});

                document.getElementById('zoomSlider').addEventListener('input', (e) => {{
                    this.viewState.zoom = parseFloat(e.target.value);
                    document.getElementById('zoomValue').textContent = this.viewState.zoom.toFixed(1);
                    this.nodeDimensionsCache.clear();
                    this.render();
                }});

                document.getElementById('nodeSizeSlider').addEventListener('input', (e) => {{
                    this.viewState.nodeScale = parseFloat(e.target.value);
                    document.getElementById('nodeSizeValue').textContent = this.viewState.nodeScale.toFixed(1);
                    this.nodeDimensionsCache.clear();
                    this.processTree();
                    this.render();
                }});

                document.getElementById('layoutSelect').addEventListener('change', (e) => {{
                    this.viewState.layout = e.target.value;
                    this.processTree();
                    this.render();
                }});

                document.getElementById('resetView').addEventListener('click', () => {{
                    this.viewState.offsetX = this.canvas.width / 2;
                    this.viewState.offsetY = this.canvas.height / 2;
                    this.viewState.zoom = 1;
                    document.getElementById('zoomSlider').value = 1;
                    document.getElementById('zoomValue').textContent = '1.0';
                    this.nodeDimensionsCache.clear();
                    this.render();
                }});
            }}

            handleClick(e) {{
                const rect = this.canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                for (const node of this.nodes) {{
                    const screen = this.worldToScreen(node.x, node.y);
                    const dimensions = this.getNodeDimensions(node);

                    const left = screen.x - dimensions.width / 2;
                    const right = screen.x + dimensions.width / 2;
                    const top = screen.y - dimensions.height / 2;
                    const bottom = screen.y + dimensions.height / 2;

                    if (clickX >= left && clickX <= right && clickY >= top && clickY <= bottom) {{
                        // Toggle expansion for long text
                        if (node.text.length > 25) {{
                            if (this.expandedNodes.has(node.id)) {{
                                this.expandedNodes.delete(node.id);
                            }} else {{
                                this.expandedNodes.add(node.id);
                            }}
                            this.nodeDimensionsCache.clear();
                            this.render();
                        }}

                        this.selectNode(node);
                        break;
                    }}
                }}
            }}

            selectNode(node) {{
                this.selectedNode = node;
                this.render();

                if (node.cluster_data && node.cluster_data.samples && node.cluster_data.samples.length > 0) {{
                    this.showClusterData(node);
                }} else {{
                    this.hideClusterData();
                }}
            }}

            showClusterData(node) {{
                document.getElementById('no-selection').classList.add('hidden');
                document.getElementById('cluster-content').classList.remove('hidden');
                document.getElementById('selected-node-text').textContent = `"${{node.text.substring(0, 50)}}..."`;

                const stats = node.cluster_data.stats || {{}};
                const statsHtml = Object.entries(stats)
                    .map(([cluster, count]) => `<div>${{cluster}}: ${{count}} samples</div>`)
                    .join('');
                document.getElementById('cluster-stats').innerHTML = `<div class="cluster-info">${{statsHtml}}</div>`;

                // Group samples by cluster
                const clusterGroups = {{}};
                node.cluster_data.samples.forEach(sample => {{
                    const clusterId = sample.cluster;
                    const clusterKey = clusterId === -1 ? 'noise' : `cluster_${{clusterId}}`;
                    if (!clusterGroups[clusterKey]) {{
                        clusterGroups[clusterKey] = [];
                    }}
                    clusterGroups[clusterKey].push(sample);
                }});

                // Generate collapsible HTML
                const clustersHtml = Object.entries(clusterGroups)
                    .sort(([a], [b]) => {{
                        // Sort: numbered clusters first, then noise
                        if (a === 'noise') return 1;
                        if (b === 'noise') return -1;
                        return a.localeCompare(b);
                    }})
                    .map(([clusterKey, samples]) => {{
                        const displayName = clusterKey === 'noise' ? 'Noise' : clusterKey.replace('_', ' ');
                        const sampleCount = samples.length;

                        const samplesHtml = samples
                            .map(sample => `<div class="sample-text" style="border-left-color: ${{sample.color}}">${{sample.text}}</div>`)
                            .join('');

                        return `
                            <div class="cluster-group">
                                <div class="cluster-header" onclick="toggleCluster('${{clusterKey}}')">
                                    <span>${{displayName}} (${{sampleCount}} samples)</span>
                                    <span class="expand-icon" id="icon-${{clusterKey}}">▼</span>
                                </div>
                                <div class="cluster-content" id="content-${{clusterKey}}">
                                    ${{samplesHtml}}
                                </div>
                            </div>
                        `;
                    }})
                    .join('');

                document.getElementById('cluster-samples').innerHTML = clustersHtml;

                const viewer = this.initClusterViewer();
                viewer.showClusters(node.cluster_data);
            }}

            hideClusterData() {{
                document.getElementById('no-selection').classList.remove('hidden');
                document.getElementById('cluster-content').classList.add('hidden');
                if (this.clusterViewer) {{
                    this.clusterViewer.clear();
                }}
            }}

            screenToWorld(screenX, screenY) {{
                return {{
                    x: (screenX - this.viewState.offsetX) / this.viewState.zoom,
                    y: (screenY - this.viewState.offsetY) / this.viewState.zoom
                }};
            }}

            worldToScreen(x, y) {{
                return {{
                    x: (x * this.viewState.zoom) + this.viewState.offsetX,
                    y: (y * this.viewState.zoom) + this.viewState.offsetY
                }};
            }}

            processTree() {{
                this.nodes = [];
                this.edges = [];

                if (this.viewState.layout === 'radial') {{
                    this.layoutRadial();
                }} else {{
                    this.layoutTree();
                }}
            }}

            layoutRadial() {{
                this.traverseRadial(this.treeData, 0, 0, 0, null, 0);
            }}

            layoutTree() {{
                this.traverseTree(this.treeData, 0, -200, null, 0);
            }}

            traverseRadial(node, x, y, parentAngle, parentId, level) {{
                const nodeId = this.nodes.length;

                this.nodes.push({{
                    id: nodeId,
                    x: x,
                    y: y,
                    text: node.token_text,
                    probability: node.probability,
                    depth: node.depth,
                    level: level,
                    parentId: parentId,
                    cluster_data: node.cluster_data
                }});

                if (parentId !== null) {{
                    this.edges.push({{ from: parentId, to: nodeId }});
                }}

                if (node.children && node.children.length > 0) {{
                    const childCount = node.children.length;
                    const baseRadius = 120 + (level * 60);
                    const effectiveRadius = baseRadius * this.viewState.nodeScale;
                    const angleSpread = Math.min(Math.PI * 1.6, Math.max(0.6, childCount * 0.4));
                    const startAngle = parentAngle - angleSpread / 2;

                    node.children.forEach((child, index) => {{
                        let childAngle = childCount === 1 ? parentAngle :
                            startAngle + (index * angleSpread / (childCount - 1));

                        const childX = x + Math.cos(childAngle) * effectiveRadius;
                        const childY = y + Math.sin(childAngle) * effectiveRadius;

                        this.traverseRadial(child, childX, childY, childAngle, nodeId, level + 1);
                    }});
                }}
            }}

            traverseTree(node, x, y, parentId, level) {{
                const nodeId = this.nodes.length;

                this.nodes.push({{
                    id: nodeId,
                    x: x,
                    y: y,
                    text: node.token_text,
                    probability: node.probability,
                    depth: node.depth,
                    level: level,
                    parentId: parentId,
                    cluster_data: node.cluster_data
                }});

                if (parentId !== null) {{
                    this.edges.push({{ from: parentId, to: nodeId }});
                }}

                if (node.children && node.children.length > 0) {{
                    const childSpacing = 160 * this.viewState.nodeScale;
                    const totalWidth = (node.children.length - 1) * childSpacing;
                    const startX = x - totalWidth / 2;
                    const verticalSpacing = 140 * this.viewState.nodeScale;

                    node.children.forEach((child, index) => {{
                        const childX = startX + (index * childSpacing);
                        const childY = y + verticalSpacing;
                        this.traverseTree(child, childX, childY, nodeId, level + 1);
                    }});
                }}
            }}

            getNodeDimensions(node) {{
                const isExpanded = this.expandedNodes.has(node.id);
                const cacheKey = `${{node.id}}-${{this.viewState.zoom}}-${{this.viewState.nodeScale}}-${{isExpanded}}`;

                if (this.nodeDimensionsCache.has(cacheKey)) {{
                    return this.nodeDimensionsCache.get(cacheKey);
                }}

                const baseScale = this.viewState.nodeScale;
                const zoomScale = Math.max(0.3, Math.min(1.2, this.viewState.zoom));
                const fontSize = Math.max(10, 14 * baseScale * zoomScale);

                this.ctx.font = `${{fontSize}}px Arial`;

                let displayText = node.text.trim();
                const hasLongText = displayText.length > 25;

                if (!isExpanded && hasLongText) {{
                    const charLimit = Math.floor(15 + (zoomScale * 10));
                    displayText = displayText.substring(0, charLimit) + '...';
                }}

                const textWidth = this.ctx.measureText(displayText).width;
                const padding = Math.max(12, 16 * baseScale);
                const width = Math.max(textWidth + padding * 2, 60 * baseScale);
                const height = Math.max(fontSize + padding * 2, 40 * baseScale);

                const dimensions = {{
                    width,
                    height,
                    padding,
                    fontSize,
                    displayText,
                    isExpanded,
                    hasLongText
                }};

                this.nodeDimensionsCache.set(cacheKey, dimensions);
                return dimensions;
            }}

            render() {{
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawEdges();
                this.drawNodes();
            }}

            drawEdges() {{
                this.ctx.lineWidth = Math.max(1, 2 * this.viewState.zoom);

                this.edges.forEach(edge => {{
                    const fromNode = this.nodes[edge.from];
                    const toNode = this.nodes[edge.to];

                    const fromScreen = this.worldToScreen(fromNode.x, fromNode.y);
                    const toScreen = this.worldToScreen(toNode.x, toNode.y);

                    const alpha = Math.max(0.3, toNode.probability);
                    this.ctx.strokeStyle = `rgba(100, 100, 100, ${{alpha}})`;

                    this.ctx.beginPath();
                    if (this.viewState.layout === 'tree') {{
                        const midY = fromScreen.y + (toScreen.y - fromScreen.y) * 0.6;
                        this.ctx.moveTo(fromScreen.x, fromScreen.y);
                        this.ctx.bezierCurveTo(fromScreen.x, midY, toScreen.x, midY, toScreen.x, toScreen.y);
                    }} else {{
                        this.ctx.moveTo(fromScreen.x, fromScreen.y);
                        this.ctx.lineTo(toScreen.x, toScreen.y);
                    }}
                    this.ctx.stroke();
                }});
            }}

            drawNodes() {{
                this.nodes.forEach(node => {{
                    const screen = this.worldToScreen(node.x, node.y);
                    this.drawNode(screen.x, screen.y, node);
                }});
            }}

            drawNode(x, y, node) {{
                const dimensions = this.getNodeDimensions(node);
                const {{ width, height, padding, fontSize, displayText, isExpanded, hasLongText }} = dimensions;

                const rectX = x - width / 2;
                const rectY = y - height / 2;
                const cornerRadius = Math.max(6, 10 * this.viewState.nodeScale);

                const hue = (node.level * 45) % 360;
                const saturation = Math.max(40, 70 - node.level * 5);
                const lightness = Math.max(35, 55 - node.level * 3);
                const color = `hsl(${{hue}}, ${{saturation}}%, ${{lightness}}%)`;

                const isSelected = this.selectedNode && this.selectedNode.id === node.id;
                const hasClusterData = node.cluster_data && node.cluster_data.samples && node.cluster_data.samples.length > 0;

                let borderColor = '#cccccc';
                let borderWidth = Math.max(1, 2 * this.viewState.zoom);

                if (isSelected) {{
                    borderColor = '#ffffff';
                    borderWidth = 3;
                }} else if (hasClusterData) {{
                    borderColor = '#00ff88';
                    borderWidth = 2;
                }}

                this.drawRoundedRect(rectX, rectY, width, height, cornerRadius);
                this.ctx.fillStyle = color;
                this.ctx.fill();

                this.ctx.strokeStyle = borderColor;
                this.ctx.lineWidth = borderWidth;
                this.ctx.stroke();

                if (this.viewState.zoom > 0.2) {{
                    this.ctx.fillStyle = '#ffffff';
                    this.ctx.font = `${{fontSize}}px Arial`;
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    this.ctx.fillText(displayText, x, y);

                    // Show expand indicator for long text
                    if (hasLongText && !isExpanded && this.viewState.zoom > 0.5) {{
                        this.ctx.fillStyle = '#aaaaaa';
                        this.ctx.font = `${{Math.max(8, fontSize * 0.7)}}px Arial`;
                        this.ctx.fillText('⋯', x + width/2 - 15, y - height/2 + 12);
                    }}
                }}
            }}

            drawRoundedRect(x, y, width, height, radius) {{
                this.ctx.beginPath();
                this.ctx.moveTo(x + radius, y);
                this.ctx.lineTo(x + width - radius, y);
                this.ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
                this.ctx.lineTo(x + width, y + height - radius);
                this.ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
                this.ctx.lineTo(x + radius, y + height);
                this.ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
                this.ctx.lineTo(x, y + radius);
                this.ctx.quadraticCurveTo(x, y, x + radius, y);
                this.ctx.closePath();
            }}
        }}

        const canvas = document.getElementById('canvas');
        const visualizer = new TreeVisualizer(canvas, treeData);

        // Global function for collapsible clusters
        function toggleCluster(clusterKey) {{
            const content = document.getElementById(`content-${{clusterKey}}`);
            const icon = document.getElementById(`icon-${{clusterKey}}`);

            if (content && icon) {{
                content.classList.toggle('collapsed');
                icon.classList.toggle('collapsed');
            }}
        }}
    </script>
</body>
</html>